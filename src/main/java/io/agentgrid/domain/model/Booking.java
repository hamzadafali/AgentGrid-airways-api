package io.agentgrid.domain.model;


import io.agentgrid.domain.enums.BookingStatus;
import io.agentgrid.domain.valueObject.BookingReference;
import io.agentgrid.domain.valueObject.Money;
import io.agentgrid.domain.valueObject.SeatNumber;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.Objects;

import static io.agentgrid.domain.util.DomainValidator.nn;
import static io.agentgrid.domain.util.DomainValidator.require;


public final class Booking {


    private final Long id;
    private final BookingReference reference;
    private final LocalDateTime bookedAt;

    private final Long flightId;
    private final Long passengerId;

    private SeatNumber seat;
    private BookingStatus status;

    private Money paidAmount; // null si non pay√©
    private LocalDateTime paidAt;

    private Booking(Long id,
                    BookingReference reference,
                    LocalDateTime bookedAt,
                    Long flightId,
                    Long passengerId,
                    SeatNumber seat) {

        this.id = id;
        this.reference = nn(reference, "Booking reference is required");
        this.bookedAt = nn(bookedAt, "BookedAt is required");
        this.flightId = nn(flightId, "FlightId is required");
        this.passengerId = nn(passengerId, "PassengerId is required");
        this.seat = nn(seat, "Seat is required");
        this.status = BookingStatus.PENDING;
    }

    public static Booking create(Long flightId, Long passengerId, SeatNumber seat, Clock clock) {
        nn(clock, "Clock is required");
        return new Booking(
                null, // id will be generated by DB
                BookingReference.newRef(),
                LocalDateTime.now(clock),
                flightId,
                passengerId,
                seat
        );
    }

    // -------- Business transitions --------

    public void confirm() {
        require(status == BookingStatus.CREATED, "Only CREATED booking can be confirmed");
        this.status = BookingStatus.CONFIRMED;
    }

    public void checkIn() {
        require(status == BookingStatus.CONFIRMED, "Only CONFIRMED booking can be checked-in");
        this.status = BookingStatus.ISSUED;
    }

    public void cancel() {
        require(status == BookingStatus.CREATED || status == BookingStatus.CONFIRMED,
                "Only CREATED or CONFIRMED booking can be cancelled");
        require(paidAmount == null, "Cannot cancel a paid booking (refund flow required)");
        this.status = BookingStatus.CANCELLED;
    }

    public void pay(Money amount, Clock clock) {
        nn(clock, "Clock is required");
        nn(amount, "Payment amount is required");
        require(status != BookingStatus.CANCELLED, "Cannot pay a cancelled booking");
        require(paidAmount == null, "Booking already paid");
        this.paidAmount = amount;
        this.paidAt = LocalDateTime.now(clock);
    }

    public void changeSeat(SeatNumber newSeat) {
        nn(newSeat, "Seat is required");
        require(status == BookingStatus.CREATED || status == BookingStatus.CONFIRMED,
                "Seat can only be changed before check-in");
        require(!newSeat.equals(this.seat), "New seat must be different");
        this.seat = newSeat;
    }

    // -------- Getters --------
    public Long id() { return id; }
    public BookingReference reference() { return reference; }
    public LocalDateTime bookedAt() { return bookedAt; }
    public Long flightId() { return flightId; }
    public Long passengerId() { return passengerId; }
    public SeatNumber seat() { return seat; }
    public BookingStatus status() { return status; }
    public Money paidAmount() { return paidAmount; }
    public LocalDateTime paidAt() { return paidAt; }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Booking other)) return false;
        return id.equals(other.id);
    }
    @Override public int hashCode() { return Objects.hash(id); }
}

